<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python基于异步库实现Redis分布式锁</title>
    <link href="/2022/07/07/Python%E5%9F%BA%E4%BA%8E%E5%BC%82%E6%AD%A5%E5%BA%93%E5%AE%9E%E7%8E%B0Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2022/07/07/Python%E5%9F%BA%E4%BA%8E%E5%BC%82%E6%AD%A5%E5%BA%93%E5%AE%9E%E7%8E%B0Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是分布式锁？"><a href="#什么是分布式锁？" class="headerlink" title="什么是分布式锁？"></a>什么是分布式锁？</h2><p>分布式锁用于控制分布式系统中不同进程共用访问共享资源的一种锁实现。在同一进程中，可以很轻易的使用锁。但是在不同进程中，就需要利用到一些中间件比如Redis实现锁的机制，以防止干扰，保证一致性。</p><h2 id="需要用到Redis哪些特征？"><a href="#需要用到Redis哪些特征？" class="headerlink" title="需要用到Redis哪些特征？"></a>需要用到Redis哪些特征？</h2><p>分布式锁主要用到Redis的setnx以及expire。<br>setnx用于设置一个key，如果该key不存在，则设置成功。反之亦然。<br>expire用于给一个key添加一个过期时间，当过期时，Redis会将该key删除。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h2 id="在这里，我使用的是Python分布式Redis库‘aioredis’。"><a href="#在这里，我使用的是Python分布式Redis库‘aioredis’。" class="headerlink" title="在这里，我使用的是Python分布式Redis库‘aioredis’。"></a>在这里，我使用的是Python分布式Redis库‘aioredis’。</h2><p>导入相关库:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs Python3">import asyncio<br>import uuid<br>import aioredis<br>import math<br>import time<br></code></pre></td></tr></table></figure><hr><p>首先我们实现一个上锁的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Python3">async def acquire_lock(app, lock_name, acquire_timeout=10, lock_timeout=10):<br>    # 生成随机身份值<br>    identifier = str(uuid.uuid4())<br>    # 锁的key值<br>    lock_name = &#x27;lock:&#x27; + lock_name<br>    # 锁的过期时间<br>    lock_timeout = int(math.ceil(lock_timeout))<br><br>    # 超时则不再尝试上锁<br>    end_acquire_time = time.time() + acquire_timeout<br>    # 从连接池获取redis对象<br>    redis = aioredis.Redis(connection_pool=app.ctx.redis_pool)<br>    while time.time() &lt; end_acquire_time:<br>        # 上锁成功<br>        if await redis.set(<br>                name=lock_name,     # 锁名<br>                value=identifier,   # 锁值<br>                ex=lock_timeout,    # 过期时间<br>                nx=True):           # 如果key存在则不上锁<br>            return identifier<br>        # 上锁失败<br>        await asyncio.sleep(1)<br>    return False<br></code></pre></td></tr></table></figure><p>这里首先会随机生成一个identifier，为什么需要这个值？这个值主要是用于对锁的持有者进行一个认证。<br>举个例子，当你对key‘test’上锁并设置了过期时间5秒，并且在代码执行完成后对该锁进行释放。然而这时候你的程序却执行了10秒，在你的key过期后，已经有其他的进程拿到了‘test’的锁。如果这时你的程序还是直接delete这个key的话，就会将别人的锁进行释放。因此这里需要一个identifier值，当你在进行delete前，会进行一个判断，如果这个key的identifier值与你的相同，则可以删除。反之不能删除。<br>如果上锁成功，该函数会返回identifier的值。反之，函数会sleep一秒，然后继续尝试上锁，默认时间是10秒。如果超过acquire_timeout,则会返回False.</p><hr><p>接着我们再写一个释放锁的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Python3">async def release_lock(app, lock_name, identifier):<br>    # 锁名<br>    lock_name = &#x27;lock:&#x27; + lock_name<br>    redis = aioredis.Redis(connection_pool=app.ctx.redis_pool)<br><br>    # 开启pipeline<br>    pipe = redis.pipeline()<br>    while True:<br>        try:<br>            # 开启对key的watch<br>            await pipe.watch(lock_name)<br><br>            # 开启事务<br>            pipe.multi()<br>            await pipe.delete(lock_name)<br>            await pipe.execute()    # 执行事务<br><br>            # 关闭watch<br>            await pipe.unwatch()<br>            break<br>        except Exception as e:<br>            print(f&quot;ERROR:&#123;e&#125;&quot;)<br>            continue<br><br>    # 关闭pipeline<br>    await pipe.close()<br>    return True<br></code></pre></td></tr></table></figure><p>这里的pipeline是什么？pipeline是Redis的一个机制，用于将多个set等指令合并，减少RTT(Round Time Trip)的影响。<br>multi则相当于事务，保证操作的原子性，但是不能实现回滚。因此这里还用了watch,watch会监听一个key，当pipe.execute时，如果这个key发现了变动，则execute的命令不会执行。</p><p>至此，上锁和解锁的函数已经完成。<br>通过这两个函数实现了分布式锁的上锁并返回identifier、设置锁的过期时间、上锁失败后的重试以及解锁的时候防止误解其他进程的锁。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Apple M1安装Tensorflow</title>
    <link href="/2022/07/02/Apple-M1%E5%AE%89%E8%A3%85Tensorflow/"/>
    <url>/2022/07/02/Apple-M1%E5%AE%89%E8%A3%85Tensorflow/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近开始在m1上跑tensorflow,但是发现一旦导入’tensorflow’这个包，就会导致整个Python退出。这个Python是由Anaconda创建的虚拟环境，排查了一下才发现原来之前安装的一直是X86的Python.</p><p>在网上看到的教程，很多人都说需要安装miniconda，或者是Python3.7 . 但是经过测试，发现是可以安装在Anaconda的Python3.9的.</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="安装ARM的Anaconda"><a href="#安装ARM的Anaconda" class="headerlink" title="安装ARM的Anaconda"></a>安装ARM的Anaconda</h3><ol><li>访问Anaconda官网 <a href="https://www.anaconda.com/">https://www.anaconda.com/</a></li><li>我下载的是图形安装版(64-Bit (M1) Graphical Installer)</li><li>M1的Anaconda安装好后，不会自动安装Anaconda-Navigator,需要的话可以自己安装<figure class="highlight cmake"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs cmake">conda <span class="hljs-keyword">install</span> anaconda-navigator<br></code></pre></td></tr></table></figure></li></ol><h3 id="安装Python环境"><a href="#安装Python环境" class="headerlink" title="安装Python环境"></a>安装Python环境</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">conda</span> create --name py39 python=<span class="hljs-number">3</span>.<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h3 id="安装-Tensorflow"><a href="#安装-Tensorflow" class="headerlink" title="安装 Tensorflow"></a>安装 Tensorflow</h3><p>首先进入conda环境</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">conda <span class="hljs-built_in">activate</span> py39<br></code></pre></td></tr></table></figure><p>安装tensorflow依赖包</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">conda <span class="hljs-keyword">install</span> -c apple tensorflow-deps<br></code></pre></td></tr></table></figure><p>安装tensorflow</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip3 <span class="hljs-keyword">install</span> tensorflow-macos<br></code></pre></td></tr></table></figure><p>安装tensorflow-metal(GPU加速)</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip3 <span class="hljs-keyword">install</span> tensorflow-metal<br></code></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python3">import sys<br>import tensorflow.keras<br>import tensorflow as tf<br>print(f&quot;Tensor Flow Version: &#123;tf.__version__&#125;&quot;)<br>print(f&quot;Keras Version: &#123;tensorflow.keras.__version__&#125;&quot;)<br>print(f&quot;Python &#123;sys.version&#125;&quot;)<br>print(tf.config.list_physical_devices(&#x27;GPU&#x27;))<br>gpu = len(tf.config.list_physical_devices(&#x27;GPU&#x27;))&gt;0<br>print(&quot;GPU is&quot;, &quot;available&quot; if gpu else &quot;NOT AVAILABLE&quot;)<br>tf.test.is_gpu_available()<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python3">Tensor Flow Version: 2.9.2<br>Keras Version: 2.9.0<br>Python 3.9.12 (main, Jun  1 2022, 06:34:44) <br>[Clang 12.0.0 ]<br>[PhysicalDevice(name=&#x27;/physical_device:GPU:0&#x27;, device_type=&#x27;GPU&#x27;)]<br>GPU is available<br>True<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>2022最新Apple M1&#x2F;Mac M1 配置安装Tensorflow环境方法(亲测可用). <a href="https://zhuanlan.zhihu.com/p/474212619">https://zhuanlan.zhihu.com/p/474212619</a></li><li>Apple MacBook M1 Anaconda安装 Tensorflow. <a href="https://zhuanlan.zhihu.com/p/445535362">https://zhuanlan.zhihu.com/p/445535362</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python异步RabbitMQ库aio_pika无法连接的问题解析</title>
    <link href="/2022/06/10/Python%E5%BC%82%E6%AD%A5RabbitMQ%E5%BA%93aio-pika%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/06/10/Python%E5%BC%82%E6%AD%A5RabbitMQ%E5%BA%93aio-pika%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在RabbitMQ创建了一个名为’&#x2F;test’的Virtual Host. 在使用pika库进行连接的时候可以正常连接上，但当使用aio_pika库的时候，总是连不上。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs Python3">credentials = pika.PlainCredentials(&#x27;user&#x27;, &#x27;password&#x27;)<br><br>connection = pika.BlockingConnection(<br>    pika.ConnectionParameters(<br>        host=&#x27;ip&#x27;,<br>        port=5672,<br>        virtual_host=&#x27;/test&#x27;,<br>        credentials=credentials<br>    )<br>)<br></code></pre></td></tr></table></figure><p>以上是同步库pika的连接代码，此时可以正常连接到服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python3">connection = await aio_pika.connect_robust(<br>    &quot;amqp://user:password@ip:port/test&quot;,<br>)<br></code></pre></td></tr></table></figure><p>以上是异步库aio_pika的连接代码，此时会产生错误’asyncio.exceptions.CancelledError’</p><p>经过排查，发现问题出在Virtual Host的命名上。由于pika库使用的是传参的形式传输virtual host,于是直接传入了一个’&#x2F;test’。但是aio_pika使用的则是amqp URL的形式，因此这里的URL需要改为”amqp:&#x2F;&#x2F;user:password@ip:port&#x2F;&#x2F;test”,也就是在port后多加上一个’&#x2F;‘,或者也可以把virtual host的名称改为’test’。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Sanic的类视图函数应该如何写装饰器？</title>
    <link href="/2022/05/21/Sanic%E7%9A%84%E7%B1%BB%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%86%99%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%9F/"/>
    <url>/2022/05/21/Sanic%E7%9A%84%E7%B1%BB%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%86%99%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在M1实现Python调用GO动态链接库</title>
    <link href="/2022/05/19/%E5%9C%A8M1%E5%AE%9E%E7%8E%B0Python%E8%B0%83%E7%94%A8GO%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"/>
    <url>/2022/05/19/%E5%9C%A8M1%E5%AE%9E%E7%8E%B0Python%E8%B0%83%E7%94%A8GO%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python异步Asyncio的使用及websocket的实现</title>
    <link href="/2022/05/16/Python%E5%BC%82%E6%AD%A5Asyncio%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8Awebsocket%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/05/16/Python%E5%BC%82%E6%AD%A5Asyncio%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8Awebsocket%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Asyncio是什么"><a href="#Asyncio是什么" class="headerlink" title="Asyncio是什么?"></a>Asyncio是什么?</h2><p>asyncio是Python的一个标准库，通过该模块，可以在Python实现异步编程和协程。</p><h2 id="为什么要用协程？"><a href="#为什么要用协程？" class="headerlink" title="为什么要用协程？"></a>为什么要用协程？</h2><p>程序执行过程中，线程的切换需要频繁的保存、加载上下文，产生消耗。而协程的切换是由程序主动切换的，相对的消耗较小。</p><h2 id="如何使用协程？"><a href="#如何使用协程？" class="headerlink" title="如何使用协程？"></a>如何使用协程？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs Python3">import asyncio<br><br>async def main():<br>    print(&#x27;Hello ...&#x27;)<br>    await asyncio.sleep(1)<br>    print(&#x27;... World!&#x27;)<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>这里参考Python官网提供的一段代码,<br>可以看到，一段基本的协程代码由三部分构成</p><p>1.导入asyncio模块</p><p>2.声明一段异步函数</p><p>和普通函数的区别是在’def’前面加上’async’。</p><p>3.执行异步函数</p><p>异步函数不能直接调用，这里分两种情况。</p><ol><li><p>在异步函数内调用异步函数</p><p> 这种情况只需要在异步函数前加上’await’就可以直接调用,如</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python3">await asyncio.sleep(1)<br></code></pre></td></tr></table></figure></li><li><p>在默认流程(同步)里调用异步函数</p><p> 需要使用asyncio模块调用，如</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python3">asyncio.run(main())<br></code></pre></td></tr></table></figure></li></ol><p>当然，asyncio也提供其他不同的函数以支持在同步、异步函数内调用异步函数。</p><h2 id="实现websocket通信"><a href="#实现websocket通信" class="headerlink" title="实现websocket通信"></a>实现websocket通信</h2><h3 id="server-py"><a href="#server-py" class="headerlink" title="server.py"></a>server.py</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python3">import asyncio<br>import websockets<br><br><br>async def handler(websocket):<br>    while True:<br>        message = await websocket.recv()<br>        await websocket.send(message)<br><br><br>async def main():<br>    async with websockets.serve(handler, &quot;&quot;, 88):<br>        await asyncio.Future()<br><br><br>if __name__ == &quot;__main__&quot;:<br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><p>这是一个基础的websocket服务端代码，通过websockets模块创建serve对象，并且绑定端口和处理函数。无论服务端接受到什么，都会向客户的返回一个相同的内容。</p><h3 id="client-py"><a href="#client-py" class="headerlink" title="client.py"></a>client.py</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python3">import asyncio<br>import websockets<br><br><br>async def connect():<br>    async with websockets.connect(&quot;ws://127.0.0.1:88&quot;) as ws:<br>        while True:<br>            data = input(&quot;&quot;)<br>            await ws.send(data)<br>            resp = await ws.recv()<br><br><br>if __name__ == &quot;__main__&quot;:<br>    asyncio.run(connect())<br></code></pre></td></tr></table></figure><p>这是一个基础的websocket客户代码，在连接server成功后可以进行发送，接受消息。网上很多的教程都是用的类似流程的代码，然而这段代码有着一个较大的问题。</p><p>如果服务端不返回的话，代码会一直在’ws.recv()’这一行堵塞，用户无法继续发送下一条消息。想象这是一个聊天室，你在发送一条消息后，必须等待好友回复后才能发送下一条消息，这合理吗？这不合理</p><p>那要如何解决呢？有两种方法</p><ol><li><p>多线程</p><p> 将发送和接受函数分别放入不同的线程中，就可以避免阻塞导致无法进入下一步流程</p></li><li><p>使用asyncio的task</p><p> 如果使用多线程的话，一个对话就需要两个线程，100个对话就需要200个线程，这对于性能的影响是致命的。不过还好，有了task，我们可以以一种很优雅的方式去处理这个问题</p></li></ol><h3 id="asyncio-task-是什么？"><a href="#asyncio-task-是什么？" class="headerlink" title="asyncio task 是什么？"></a>asyncio task 是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python3">await asyncio.sleep(5)<br></code></pre></td></tr></table></figure><p>这是一行调用异步函数的代码，在这行代码里，执行与等待在同一位置。只有当这个异步函数执行完成后，阻塞才会消失</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python3">task = asyncio.create_task(asyncio.sleep(5))<br>print(&quot;hello&quot;)<br>await task<br></code></pre></td></tr></table></figure><p>这段代码通过创建task的方式调用异步函数，在第一行执行时，异步函数就会启动。不同于await方式，task的任务启动后并不会阻塞，而是继续往下执行,也就是打印’hello’。直到碰到该任务对应的await才会阻塞。</p><h3 id="优化client"><a href="#优化client" class="headerlink" title="优化client"></a>优化client</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Python3">import asyncio<br>import websockets<br><br>async def recv(ws):<br>    async for message in ws:<br>        print(message)<br><br><br>async def send(ws):<br>    while True:<br>        data = input(&quot;&quot;)<br>        await ws.send(data)<br><br><br>async def connect():<br>    async with websockets.connect(&quot;ws://127.0.0.1:88&quot;) as ws:<br>        while True:<br>            send_task = asyncio.create_task(send(ws))<br>            recv_task = asyncio.create_task(recv(ws))<br><br>            await send_task<br>            await recv_task<br><br><br>if __name__ == &quot;__main__&quot;:<br>    asyncio.run(connect())<br></code></pre></td></tr></table></figure><p>通过这一特性，我们可以使用task对client的代码进行优化。</p><p>首先，我们分别对发送和接受创建两个异步函数。再使用task的方式启动函数，并且配合await保持异步函数能够一直运行。这样我们就实现了任意的发送和接受消息。</p><h2 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h2><ol><li>Python.org. asyncio异步 I&#x2F;O. <a href="https://docs.python.org/zh-cn/3/library/asyncio.html">https://docs.python.org/zh-cn/3/library/asyncio.html</a></li><li>Websockets. <a href="https://websockets.readthedocs.io/en/stable/intro/index.html">https://websockets.readthedocs.io/en/stable/intro/index.html</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>yarn安装vue/cli后无法在命令行通过vue执行命令的解决方法</title>
    <link href="/2022/03/12/yarn%E5%AE%89%E8%A3%85vue-cli%E5%90%8E%E6%97%A0%E6%B3%95%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%9A%E8%BF%87vue%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2022/03/12/yarn%E5%AE%89%E8%A3%85vue-cli%E5%90%8E%E6%97%A0%E6%B3%95%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%9A%E8%BF%87vue%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>根据vue官方文档，可以通过以下命令安装vue脚手架</p><figure class="highlight llvm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs llvm">yarn <span class="hljs-keyword">global</span> <span class="hljs-keyword">add</span> <span class="hljs-title">@vue</span>/cli<br></code></pre></td></tr></table></figure><p>但是在安装好后，不能通过vue执行命令</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>检查安装时的用户是否为root<br>1.删除此前安装的vue</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">yarn <span class="hljs-keyword">global</span> remove <span class="hljs-symbol">@vue</span>/cli<br></code></pre></td></tr></table></figure><p>2.用超级用户重新安装</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">sudo yarn <span class="hljs-keyword">global</span> <span class="hljs-keyword">add</span> <span class="hljs-title">@vue</span>/cli<br></code></pre></td></tr></table></figure><p>3.执行命令启动</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">vue</span><br></code></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>1.Command not found with vue-cli.(<a href="https://stackoverflow.com/questions/51172064/command-not-found-with-vue-cli">https://stackoverflow.com/questions/51172064/command-not-found-with-vue-cli</a>)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu上基Docker的Adguard Home自建DNS系统搭建</title>
    <link href="/2021/12/12/Ubuntu%E4%B8%8A%E5%9F%BADocker%E7%9A%84Adguard-Home%E8%87%AA%E5%BB%BADNS%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/12/12/Ubuntu%E4%B8%8A%E5%9F%BADocker%E7%9A%84Adguard-Home%E8%87%AA%E5%BB%BADNS%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着DNS污染、速度慢，广告多等情况日益严重，自建DNS服务成了越来越多人的选择。本项目利用Docker搭建，主要是考虑到搭建便利，更新成本低。在搭建完成后，可以针对广告、成人内容等进行屏蔽，提升上网冲浪体验。</p><h2 id="安装-Adguard-Home"><a href="#安装-Adguard-Home" class="headerlink" title="安装 Adguard Home"></a>安装 Adguard Home</h2><figure class="highlight docker"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs Docker">docker <span class="hljs-keyword">run</span><span class="language-bash"> --name adguardhome\</span><br><span class="language-bash">--restart unless-stopped\</span><br><span class="language-bash">-p 53:53/tcp -p 53:53/udp\</span><br><span class="language-bash">-p 3000:3000\</span><br><span class="language-bash">-d adguard/adguardhome</span><br></code></pre></td></tr></table></figure><p>执行以上Docker命令即可快速的创建并运行一个Adguard Home容器。其中，53端口为DNS服务的默认端口，由于部分操作系统在指定DNS服务器的时候不支持指定端口，因此这里不建议修改。3000端口为项目管理后台WEB界面的端口，可以自行修改。</p><p><strong>端口被占用</strong><br>在Ubuntu情况下可能会由于53端口占用导致无法正常创建允许容器，这是由于系统自带的’systemd-resolved.service’在负责dns的处理，因此只要把这个服务关了，就可以释放53端口</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo systemctl disable systemd-resolved.service<br>sudo systemctl stop systemd-resolved<br><br>nano <span class="hljs-regexp">/etc/</span>NetworkManager/NetworkManager.conf<br><span class="hljs-comment"># 设置dns=default</span><br><br>rm <span class="hljs-regexp">/etc/</span>resolv.conf<br>sudo service network-manager restart<br></code></pre></td></tr></table></figure><h2 id="Adguard-Home初始化设置"><a href="#Adguard-Home初始化设置" class="headerlink" title="Adguard Home初始化设置"></a>Adguard Home初始化设置</h2><p>在容器正常运行后，就可以访问 <a href="http://127.0.0.1:3000/">http://127.0.0.1:3000</a> 进到初始化界面。</p><img src="/2021/12/12/Ubuntu%E4%B8%8A%E5%9F%BADocker%E7%9A%84Adguard-Home%E8%87%AA%E5%BB%BADNS%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/img1.png" class=""><img src="/2021/12/12/Ubuntu%E4%B8%8A%E5%9F%BADocker%E7%9A%84Adguard-Home%E8%87%AA%E5%BB%BADNS%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/img2.png" class=""><img src="/2021/12/12/Ubuntu%E4%B8%8A%E5%9F%BADocker%E7%9A%84Adguard-Home%E8%87%AA%E5%BB%BADNS%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/img3.png" class=""><p>初始化完成，进入仪表盘界面</p><img src="/2021/12/12/Ubuntu%E4%B8%8A%E5%9F%BADocker%E7%9A%84Adguard-Home%E8%87%AA%E5%BB%BADNS%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/img4.png" class=""><h2 id="Adguard-Home进阶设置"><a href="#Adguard-Home进阶设置" class="headerlink" title="Adguard Home进阶设置"></a>Adguard Home进阶设置</h2><p>根据不同地理位置配置上游DNS服务器，可以提高Adguard Home查询DNS的速度。具体上游DNS服务器可以参考”Adguard Home Known DNS Providers”</p><p>同样，在过滤器增加规则，可以对广告相关的域名进行屏蔽.</p><ol><li><strong>anti-AD</strong><blockquote><p>GitHub：<br><a href="https://raw.githubusercontent.com/privacy-protection-tools/anti-AD/master/anti-ad-easylist.txt">https://raw.githubusercontent.com/privacy-protection-tools/anti-AD/master/anti-ad-easylist.txt</a><br>官网地址：<br><a href="https://anti-ad.net/easylist.txt">https://anti-ad.net/easylist.txt</a></p></blockquote></li></ol><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><blockquote><ol><li>Adding AdGuard to Home Assistant on Hassio on Ubuntu 18.04. [online]Available at &lt;<a href="https://eviltyrant.com/wordpress/2019/07/adding-adguard-to-home-assistant-on-hassio-on-ubuntu-18-04/">https://eviltyrant.com/wordpress/2019/07/adding-adguard-to-home-assistant-on-hassio-on-ubuntu-18-04/</a>&gt;(2021&#x2F;12&#x2F;12)</li><li>P3TERX,(2020). <em>AdGuard Home 自建 DNS 防污染、去广告教程 #1 - 安装部署详解(Docker)</em>.[online]Available at &lt;<a href="https://p3terx.com/archives/use-adguard-home-to-build-dns-to-prevent-pollution-and-remove-ads-1.html">https://p3terx.com/archives/use-adguard-home-to-build-dns-to-prevent-pollution-and-remove-ads-1.html</a>&gt;(2021&#x2F;12&#x2F;12)</li><li>Known DNS Providers. [online]Available at &lt;<a href="https://kb.adguard.com/zh/general/dns-providers">https://kb.adguard.com/zh/general/dns-providers</a>&gt;(2021&#x2F;12&#x2F;12)</li><li>chjina,(2021). <em>AdGuard 过滤规则分享</em>.[online]Available at &lt;<a href="https://chjina.com/archives/11/">https://chjina.com/archives/11/</a>&gt;(2021&#x2F;12&#x2F;12)</li></ol></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx转发nextcloud请求 导致nextcloud客户端无法正常访问</title>
    <link href="/2021/08/01/nginx%E8%BD%AC%E5%8F%91nextcloud%E8%AF%B7%E6%B1%82-%E5%AF%BC%E8%87%B4nextcloud%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E8%AE%BF%E9%97%AE/"/>
    <url>/2021/08/01/nginx%E8%BD%AC%E5%8F%91nextcloud%E8%AF%B7%E6%B1%82-%E5%AF%BC%E8%87%B4nextcloud%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>nextcloud是一款较为流行的私有云解决方案，近期在搭建nextcloud的时候发现 网页可以正常访问，但是客户端无法访问。 经过研究，发现了问题的所在并找到了解决方法</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>为了提高安全性，nextcloud的配置中有一项内容”信任域名”(trusted_domains). 在config&#x2F;config.php中可以看到。只有通过信任域名配置中的域名访问nextcloud，请求才会被正常的解析并返回。<br>而nextcloud是怎么判断用户的请求域名呢？答案是根据http请求的host参数</p><p>很多人在配置nginx转发请求的时候，直接使用了 proxy_pass 进行转发，这样会导致原请求中的一些信息的丢失。从而导致nextcloud无法判断用户是根据哪个请求进行访问的，因此才会出现无法访问的情况<br>解决的方法也很简单，在nginx转发之前加一行</p><figure class="highlight nginx"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$http_host</span>;<br></code></pre></td></tr></table></figure><p>该命令会将用户访问nginx请求中的Host变量同时转发给nextcloud，这样nextcloud就可以知道该请求是否合规。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Frp使用教程</title>
    <link href="/2021/08/01/Frp%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2021/08/01/Frp%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="frp是什么？"><a href="#frp是什么？" class="headerlink" title="frp是什么？"></a>frp是什么？</h2><p>frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。</p><p>由于ipv4地址有限，并不是所有家庭用户都能分配到一个公网的ipv4地址，即使有一个公网地址，仍然无法使用像80\443这类的端口。这时我们就可以考虑使用frp。</p><p>frp由两部分组成，frps(服务端) 和 frpc(客户端).frps部署在一个有公网ip的服务器上，frpc部署在没有公网的服务器上。当用户以特定端口访问frps时，frps则会将接受到的请求转发到frpc，再由frpc进行访问。这样我们就实现了在没有公网的服务器上也能接受到外网的访问请求。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在frp官方的github仓库下载适合的版本，解压到服务器和客户端上，每个版本都同时包含了服务端和客户端。<a href="https://github.com/fatedier/frp/releases">下载地址</a></p><h3 id="服务端的安装"><a href="#服务端的安装" class="headerlink" title="服务端的安装"></a>服务端的安装</h3><p>在服务端上打开我们解压后的文件夹，找到frps.ini文件进行编辑(文件名随意，因为在启动frps的时候会指定配置文件)</p><figure class="highlight ini"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># frps.ini</span><br><span class="hljs-section">[common]</span><br><span class="hljs-attr">bind_port</span> = <span class="hljs-number">7000</span><br><span class="hljs-attr">vhost_http_port</span> = <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>该配置由三行组成，第一行为告诉frps下面是配置<br>第二行我们开了一个端口’7000’,这个端口用于与frpc客户端进行通讯<br>第三行我们开了一个端口‘8080’,这个端口用于接受用户发送的http&#x2F;https请求</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 命令行启动服务端</span><br>.<span class="hljs-regexp">/frps -c ./</span>frps.ini<br></code></pre></td></tr></table></figure><h3 id="客户端的安装"><a href="#客户端的安装" class="headerlink" title="客户端的安装"></a>客户端的安装</h3><p>同样打开解压后的文件夹，我们打开文件夹里的frpc.ini文件，这里同样也是可以随意取名的</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># frpc.ini</span><br><span class="hljs-section">[common]</span><br><span class="hljs-attr">server_addr</span> = x.x.x.x<br><span class="hljs-attr">server_port</span> = <span class="hljs-number">7000</span><br><br><span class="hljs-section">[web]</span><br><span class="hljs-attr">type</span> = http<br><span class="hljs-attr">local_port</span> = <span class="hljs-number">80</span><br><span class="hljs-attr">custom_domains</span> = www.yourdomain.com<br><br><span class="hljs-section">[web2]</span><br><span class="hljs-attr">type</span> = http<br><span class="hljs-attr">local_port</span> = <span class="hljs-number">8080</span><br><span class="hljs-attr">custom_domains</span> = www.yourdomain2.com<br></code></pre></td></tr></table></figure><p>在frpc配置文件里我们分为3大部分，第一是common，和frps的配置一样是特定名称.第二和第三是web和web2,这里我们可以随意取名<br>首先我们在common里配置了frps的地址和通讯端口.这部分配置用于和服务端的连接</p><p>其次在web和web2中，我们都指定了三个配置. type, local_port 以及 custom_domains.<br>type配置代表连接的类型，如tcp, udp, http.<br>local_port和domains代表，当一个用户访问domains的时候，frp会将指定的domain解析到制定的port. 比如这里我们访问 <a href="http://www.yourdomain.com/">www.yourdomain.com</a> ,frps就会转发请求到frpc的80端口，<br>如果访问的是 <a href="http://www.yourdomain2.com/">www.yourdomain2.com</a> , frps就会转发请求到frpc的8080端口。当然，前提是你需要把这两个域名都解析到frps所在的服务器。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 命令行启动客户端</span><br>.<span class="hljs-regexp">/frpc -c ./</span>frpc.ini<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>到这里，我们基本完成了frp的简单配置。但是不知道你们是否发现了一个问题，在上面的配置中，我们并没有对frp的通讯进行一个验证。此时如果frps和frpc的连接断开了，在断开的时候被他人用他们的frpc连接到我们的frps，那么所有原本打算访问我们的frps就会全部转发到他人的frpc。这将会造成一个巨大的隐患。</p><p>当然，frp同样有对应的解决方法，那就是<strong>身份认证</strong>.<br>身份认证的配置也很简单，我们只需要同时在frps和frpc的配置文件的’common’中加一行(token的值随意，但是一定要确保两端的值一样)</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">token</span> <span class="hljs-operator">=</span> asjkdjalk<br></code></pre></td></tr></table></figure><p>这样每次frpc连接frps的时候，都会进行一个身份验证，只有验证通过后才会真正的连接，这样就避免了安全问题的发生</p><p><a href="https://gofrp.org/docs/">官方文档</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 多线程以及四种常见的锁 基本使用介绍</title>
    <link href="/2021/05/30/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E5%9B%9B%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%81-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/05/30/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E5%9B%9B%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%81-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于GIL的限制，python的多线程实际上只用到了cpu的单核。在计算密集型的程序中，python的多线程对提升效率的影响并不大。但在I&#x2F;O密集型的程序中，python的多线程便能极大的提高运行效率</p><h2 id="一个简单的多线程程序"><a href="#一个简单的多线程程序" class="headerlink" title="一个简单的多线程程序"></a>一个简单的多线程程序</h2><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">output</span>(<span class="hljs-params">value</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-built_in">print</span>(value)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    t_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        t = threading.Thread(target=output, args=[i])<br>        t.start()<br>        t_list.append(t)<br>    <br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> t_list:<br>        t.join()<br></code></pre></td></tr></table></figure><p>这段代码主要分为两个部分，一部分是函数的定义，另一部分是多线程的启动。<br>首先创建了三个线程，将线程加入到数组并启动。使用join方法的目的是保证所有线程都执行完毕后才会接着去执行join以下的代码。或是让主线程等待所有子线程执行结束后再结束</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 输出结果</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>由于pytho中的多线程是单核处理的，在执行多线程任务的时候，会在线程间进行切换。这里从不规则的输出结果中也可以直观的看出。在I&#x2F;O密集的程序中，如爬虫，在遇到requests等待的时候，python会切换到其他的线程进行执行，提高了整体的工作效率。</p><h2 id="多线程冲突"><a href="#多线程冲突" class="headerlink" title="多线程冲突"></a>多线程冲突</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python">num = <span class="hljs-number">0</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>():<br>    <span class="hljs-keyword">global</span> num<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):<br>        num += <span class="hljs-number">1</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    t_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        t = threading.Thread(target=add)<br>        t.start()<br>        t_list.append(t)<br>    <br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> t_list:<br>        t.join()<br><br>    <span class="hljs-built_in">print</span>(num)<br><span class="hljs-comment"># Output</span><br><span class="hljs-comment"># 7483658</span><br></code></pre></td></tr></table></figure><p>在使用多线程的时候，难免需要操作共同的变量。在上面的例子中，如果只是简单直接的操作，就会造成线程冲突的情况。<br>这是因为在执行 num +&#x3D;1 的时候，实际上执行了三个步骤</p><ol><li>拿到num的值</li><li>给拿到的num加1</li><li>将处理后的值赋值给num<br>上面提到过，python会在多线程直接进行切换。如果在执行完第一步以后，切换到了其他线程B.执行完线程B后再返回执行2和3,就会导致赋予的值比实际的值更小。为了避免这种情况，就需要用到锁</li></ol><h2 id="四种锁的基本使用"><a href="#四种锁的基本使用" class="headerlink" title="四种锁的基本使用"></a>四种锁的基本使用</h2><h3 id="互斥锁Lock"><a href="#互斥锁Lock" class="headerlink" title="互斥锁Lock"></a>互斥锁Lock</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Python3">lock = threading.Lock()<br>num = 0<br>def add():<br>    global num<br>    lock.acquire()<br>    for i in range(1000000):<br>        num += 1<br>    lock.release()<br><br>if __name__ == &quot;__main__&quot;:<br>    t_list = []<br>    for i in range(10):<br>        t = threading.Thread(target=add)<br>        t.start()<br>        t_list.append(t)<br>    <br>    for t in t_list:<br>        t.join()<br>    <br>    print(num)<br># Output<br># 10000000<br></code></pre></td></tr></table></figure><p>互斥锁是比较常见的一种锁。首先我们需要创建一个锁的对象 lock.<br>在要执行可能冲突的指令前加上锁 lock.acquire().此时如果其他的线程要访问时，就会阻塞在这里。知道这里的锁被释放。这样就保证了数据的正确性</p><h3 id="递归锁Rlock"><a href="#递归锁Rlock" class="headerlink" title="递归锁Rlock"></a>递归锁Rlock</h3><p>在程序的执行过程中，可能会遇到这种情况<br>线程A锁了资源a, 线程B锁了资源b<br>此时A要访问资源b， B要访问资源a. 但因为资源都被加了锁的原因，导致它们谁都访问不了，这样就产生了死锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python3">lock = threading.RLock()<br>num = 0<br>def add():<br>    global num<br>    lock.acquire()<br>    for i in range(1000000):<br>        lock.acquire()<br>        num += 1<br>        lock.release()<br>    lock.release()<br></code></pre></td></tr></table></figure><p>递归锁内部维持着一个counter，如果counter的值为0，则其他线程可以进行加锁，并且counter的值加1.<br>如果counter的值不为0，递归锁会对需要加锁的线程进行判断，如果该线程与当前递归锁的线程一致，则允许再次上锁并且counter+1. 当对递归锁进行释放，counter便会减1，知道变为0才允许其他的线程访问。这样就避免了出现死锁的情况.</p><h3 id="条件锁Condition"><a href="#条件锁Condition" class="headerlink" title="条件锁Condition"></a>条件锁Condition</h3><p>条件锁主要新增了两个方法， notify和wait。 当当前状态为wait时，程序会阻塞在这里，知道其他进程执行了notify进行通知，才会继续执行下面的步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Python3">import threading<br>import time<br>import random<br><br>con = threading.Condition()<br>pot = []<br>def pro():  # 生产者<br>    print(&quot;pro start&quot;)<br>    con.acquire()<br>    print(&quot;pro acquire&quot;)<br>    while True:<br>        time.sleep(random.randint(1, 3))<br>        pot.append(&quot;鱼丸&quot;)<br>        print(f&quot;生产了一个鱼丸，现在锅里有&#123;len(pot)&#125;个鱼丸&quot;)<br>        if len(pot) &gt;= 5:<br>            con.notify()<br>            con.wait()<br><br>def eat():  # 消费者<br>    print(&quot;eat start&quot;)<br>    con.acquire()<br>    print(&quot;eat acquire&quot;)<br>    while True:<br>        time.sleep(random.randint(1, 3))<br>        pot.pop()<br>        print(f&quot;吃了一个鱼丸，现在锅里还有&#123;len(pot)&#125;个鱼丸&quot;)<br>        if len(pot) == 0:<br>            con.notify()<br>            con.wait()<br><br>pro = threading.Thread(target=pro)<br>eat = threading.Thread(target=eat)<br>pro.start()<br>eat.start()<br></code></pre></td></tr></table></figure><p>这里用常见的生产者消费者的关系来演示。生产者的线程首先被启动并且拿到锁，于此同时消费者也被启动，但是没有拿到锁 进入阻塞状态。生产者开始生产鱼丸，当鱼丸的个数大于等于5时，便会通知其他在阻塞状态的线程，并且自己通过wait进入阻塞。<br>阻塞状态的消费者在接受到生产者的notify消息时，便开始消费锅内的鱼丸。直到锅内没有鱼丸的时候，用notify通知其他阻塞状态中的线程，并且自己进入wait状态。一直循环</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">pro <span class="hljs-literal">start</span><br>pro acquire<br>eat <span class="hljs-literal">start</span><br>生产了一个鱼丸，现在锅里有<span class="hljs-number">1</span>个鱼丸<br>生产了一个鱼丸，现在锅里有<span class="hljs-number">2</span>个鱼丸<br>生产了一个鱼丸，现在锅里有<span class="hljs-number">3</span>个鱼丸<br>生产了一个鱼丸，现在锅里有<span class="hljs-number">4</span>个鱼丸<br>生产了一个鱼丸，现在锅里有<span class="hljs-number">5</span>个鱼丸<br>eat acquire<br>吃了一个鱼丸，现在锅里还有<span class="hljs-number">4</span>个鱼丸<br>吃了一个鱼丸，现在锅里还有<span class="hljs-number">3</span>个鱼丸<br>吃了一个鱼丸，现在锅里还有<span class="hljs-number">2</span>个鱼丸<br>吃了一个鱼丸，现在锅里还有<span class="hljs-number">1</span>个鱼丸<br>吃了一个鱼丸，现在锅里还有<span class="hljs-number">0</span>个鱼丸<br>生产了一个鱼丸，现在锅里有<span class="hljs-number">1</span>个鱼丸<br>生产了一个鱼丸，现在锅里有<span class="hljs-number">2</span>个鱼丸<br>生产了一个鱼丸，现在锅里有<span class="hljs-number">3</span>个鱼丸<br>生产了一个鱼丸，现在锅里有<span class="hljs-number">4</span>个鱼丸<br>生产了一个鱼丸，现在锅里有<span class="hljs-number">5</span>个鱼丸<br>吃了一个鱼丸，现在锅里还有<span class="hljs-number">4</span>个鱼丸<br>吃了一个鱼丸，现在锅里还有<span class="hljs-number">3</span>个鱼丸<br>吃了一个鱼丸，现在锅里还有<span class="hljs-number">2</span>个鱼丸<br></code></pre></td></tr></table></figure><h3 id="信号量semaphore"><a href="#信号量semaphore" class="headerlink" title="信号量semaphore"></a>信号量semaphore</h3><p>多线程能够提升I&#x2F;O密集程序的效率，但并不意味着线程越多越好，因为多线程在切换的时候也会消耗一定的系统资源。此时我们就可以通过信号量对锁的数量进行限制，保证一定的效率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Python3">import threading<br>import time<br><br>sema = threading.Semaphore(3)<br>def func():<br>    sema.acquire()<br>    print(time.time())<br>    time.sleep(3)<br>    sema.release()<br><br>t_list = []<br>for i in range(10):<br>    t = threading.Thread(target=func)<br>    t_list.append(t)<br>    t.start()<br><br>for t in t_list:<br>    t.join()<br># Output<br>#1622450593.179221<br>#1622450593.179297<br>#1622450593.179469<br>#1622450596.179563<br>#1622450596.179789<br>#1622450596.179818<br>#1622450599.179777<br>#1622450599.179847<br>#1622450599.180023<br>#1622450602.18302<br></code></pre></td></tr></table></figure><p>这里我们设置了semaphore的数量为3，启动了10个线程。通过输出我们可以看到实际上每次只有3个线程拿到了锁。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>从零开始搭一个树莓派</title>
    <link href="/2021/04/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E4%B8%80%E4%B8%AA%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    <url>/2021/04/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E4%B8%80%E4%B8%AA%E6%A0%91%E8%8E%93%E6%B4%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>新入了一个树莓派4b，开始了漫长的配置过程。记录一下，以便以后可以参考。配置是树莓派4b, 西部数据的2t移动硬盘。硬盘直接通过usb口连接树莓派，可以用fdisk格式化硬盘。</p><h2 id="系统选择"><a href="#系统选择" class="headerlink" title="系统选择"></a>系统选择</h2><p>在操作系统上，我选择的是 <a href="https://ubuntu.com/download/raspberry-pi">Ubuntu</a>的20.04(LTS)， 原因是因为ubuntu对树莓派的支持比较好，而且更习惯用ubuntu.</p><h2 id="更换apt源"><a href="#更换apt源" class="headerlink" title="更换apt源"></a>更换apt源</h2><p>ubuntu默认的源可以会出现下载缓慢的情况，我们可以更换ubuntu的源到国内的服务提供商。<br>这里我选择的是清华提供的源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs language">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse<br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse<br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse<br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse<br></code></pre></td></tr></table></figure><p><strong>这里有个容易踩坑的地方，在网上搜索源的时候，大概率搜到的都是amd64的源，但是树莓派是arm架构的，如果用了amd的源会导致无法正常使用。所以把每一条url最后的 &#x2F;ubuntu&#x2F; 改成 &#x2F;ubuntu-ports&#x2F;</strong></p><h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><p>Nginx不仅可以做到均衡负载，还可以针对不同的host转发到不同的服务。安装也十分便捷</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">apt update<br>apt <span class="hljs-keyword">install</span> nginx<br></code></pre></td></tr></table></figure><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>Docker可以避免在部署不同的服务时造成的环境冲突问题，在遇到问题时也可以很方便的替换出问题的部分。<br>这里用安装包的方式安装docker(比较省事)。 <a href="https://docs.docker.com/engine/install/ubuntu/">参考文档</a><br>下载好合适自己系统的安装包，containerd、docker-ce-cli、以及 docker-ce 后就可以用dpkg -i 安装，需要按照上面的顺序安装</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 安装好后输入下面的命令，如果正常显示就大概没有什么问题</span><br>docker <span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure><h2 id="在Docker中安装nextcloud"><a href="#在Docker中安装nextcloud" class="headerlink" title="在Docker中安装nextcloud"></a>在Docker中安装nextcloud</h2><p>nextcloud官方提供了一个docker的镜像</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull nextcloud<br><span class="hljs-attribute">docker</span> run -d -p <span class="hljs-number">8080</span>:<span class="hljs-number">80</span> nextcloud<br></code></pre></td></tr></table></figure><p>使用上面的两行命令就可以快速的创建一个nextcloud的容器</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">创建Nginx的配置文件 nextcloud.conf<br>server &#123;<br><br>        listen <span class="hljs-number">80</span>;<br>        server_name <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>;<br>        <span class="hljs-keyword">location</span> <span class="hljs-title">/ &#123;</span><br><span class="hljs-title">                proxy_pass</span> http://docker.ip;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>把docker.ip替换成自己的dockerip，再重载nginx，此时访问 127.0.0.1 就会跳转到nextcloud的页面<br>ps:这里又一个容器踩坑的地方 因为在使用nextcloud的时候使用了nginx作为反向代理，所以可能会触发nextcloud的‘可信域名’机制，可以参考<a href="https://www.orgleaf.com/3200.html">这篇文章</a>解决。</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>到此为止就完成了树莓派的基本配置，期待发掘更多功能</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx反向代理的转发规则是怎么处理的?</title>
    <link href="/2020/12/26/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E8%BD%AC%E5%8F%91%E8%A7%84%E5%88%99%E6%98%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E7%9A%84/"/>
    <url>/2020/12/26/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E8%BD%AC%E5%8F%91%E8%A7%84%E5%88%99%E6%98%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Nginx是一个高性能的HTTP和反向代理web服务器.因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名</p><h2 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h2><p>总所周知，Nginx可以通过修改配置文件以开启反向代理。但是具体的转发规则是怎么实现的呢？<br><em><strong>Nginx配置文件</strong></em></p><figure class="highlight nginx"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br><br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br><br>        <span class="hljs-attribute">server_name</span> <span class="hljs-number">127.0.0.1</span>;<br><br><br>        <span class="hljs-section">location</span> / &#123;<br>                <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8080;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上配置使Nginx监听127.0.0.1的80端口，并将消息转发到 127.0.0.1:8080<br>如:在浏览器访问<a href="http://127.0.0.1/">http://127.0.0.1/</a>, 则nginx会访问<a href="http://127.0.0.1:8080/,%E5%B9%B6%E5%B0%86%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E">http://127.0.0.1:8080/,并将结果返回</a><br>但是在实测中发现，即使你访问的URL为 <a href="http://127.0.0.1/articles/">http://127.0.0.1/articles/</a>, nginx也可以正确的返回结果，可是我们并没有在location里把&#x2F;articles&#x2F;给加入，这是为什么？</p><h3 id="用Flask写一个web服务器"><a href="#用Flask写一个web服务器" class="headerlink" title="用Flask写一个web服务器"></a>用Flask写一个web服务器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python3">from flask import Flask<br>app = Flask(__name__)<br><br>@app.route(&quot;/&quot;)<br>def start():<br>    return &quot;im start&quot;<br><br>@app.route(&quot;/sec/&quot;)<br>def sec():<br>    return &quot;im sec&quot;<br><br>@app.route(&quot;/sec/haha/&quot;)<br>def haha():<br>    return &quot;im haha&quot;<br><br>@app.route(&quot;/haha/&quot;)<br>def ha():<br>    return &quot;im ha&quot;<br><br>if __name__ == &quot;__main__&quot;:<br>    app.run(&quot;127.0.0.1&quot;, 8080, debug=True)<br></code></pre></td></tr></table></figure><p>在这段代码里，我们设置了三个路由。在原先的Nginx配置下， 访问对应的URL可以得到对应的内容</p><ol><li>“&#x2F;“， 返回”im start”</li><li>“&#x2F;sec&#x2F;“, 返回”im sec”</li><li>“&#x2F;sec&#x2F;haha&#x2F;“, 返回”im haha”</li><li>“&#x2F;haha&#x2F;“ 返回”im ha”</li></ol><h3 id="此时我们修改一下nginx的配置"><a href="#此时我们修改一下nginx的配置" class="headerlink" title="此时我们修改一下nginx的配置"></a>此时我们修改一下nginx的配置</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br><br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br><br>        <span class="hljs-attribute">server_name</span> <span class="hljs-number">127.0.0.1</span>;<br><br><br>        <span class="hljs-section">location</span> / &#123;<br>                <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8080;<br>        &#125;<br><br><span class="hljs-section">location</span> /sec &#123;<br><span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8080;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在新的nginx配置中，我们添加了&#x2F;sec这个路由。此时访问上面的4个URL会发生什么？</p><ol><li>“&#x2F;“， 返回”im start”</li><li>“&#x2F;sec&#x2F;“, 返回”<strong>im start</strong>“</li><li>“&#x2F;sec&#x2F;haha&#x2F;“, 返回”<strong>im ha</strong>“</li><li>“&#x2F;haha&#x2F;“ 返回”im ha”</li></ol><p>可以看到，有两条URL的返回内容变了<br>因此可以判断，在nginx中的location是根据最长匹配到的URL进行分配的。当我们访问 “&#x2F;sec” 这样的URL时，由于它的长度比 “&#x2F;“长，因此nginx匹配到了第二个location所对应的服务器。并且将匹配完成后剩余的URL部分重新拼接</p><p>如:当访问<a href="http://127.0.0.1/sec/haha">http://127.0.0.1/sec/haha</a> 的时候，由于”&#x2F;sec”部分已经被匹配，因此把剩余的部分 “&#x2F;haha” 拼接到 “<a href="http://127.0.0.1:8080&quot;">http://127.0.0.1:8080&quot;</a> 后，变成了 “<a href="http://127.0.0.1:8080/haha&quot;">http://127.0.0.1:8080/haha&quot;</a>, 这才造成了我们访问以上URL时返回不同结果的原因</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python的蓝图是什么?</title>
    <link href="/2020/12/24/Python%E7%9A%84%E8%93%9D%E5%9B%BE%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2020/12/24/Python%E7%9A%84%E8%93%9D%E5%9B%BE%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Flask是一个轻量级的python web框架，相对于django，flask只需要很简单的几行代码就可以跑起一个小型的web后台。但是当flask项目开始慢慢扩大的时候，就会出现代码过于混乱，不好管理等现象。此时就需要用到flask的蓝图功能</p><h2 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h2><p>如果用过django就很容易理解蓝图功能<br>可以把蓝图比喻成一个app，假如需要写一个论坛，论坛会包含很多的模块。比如:用户管理、文章管理等。 为了方便管理代码，就使用flask创建一个用户管理的蓝图、一个文章管理的蓝图，再把它们联合起来运行</p><h3 id="基础的flask代码-start-py"><a href="#基础的flask代码-start-py" class="headerlink" title="基础的flask代码(start.py)"></a>基础的flask代码(start.py)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs python3">from flask import Flask<br><br>app = Flask(__name__)<br><br>@app.route(&#x27;/&#x27;)<br>def startIndex():<br>    return &quot;I&#x27;m start index&quot;<br><br>if __name__ == &quot;__main__&quot;:<br>    app.run(&#x27;127.0.0.1&#x27;, 80, debug=True)<br></code></pre></td></tr></table></figure><p>在执行这个文件后，我们就可以通过 <a href="http://127.0.0.1/">http://127.0.0.1/</a> 访问，会看到”I’m start index”的字样</p><p>一个论坛肯定不会只有’&#x2F;‘这一条路由，如果把所有路由都写在同一个py文件里，那会对后期维护造成极大的困扰</p><h3 id="创建一个蓝图"><a href="#创建一个蓝图" class="headerlink" title="创建一个蓝图"></a>创建一个蓝图</h3><p>一段创建蓝图的代码(article.py)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python3">from flask import Blueprint<br><br>article = Blueprint(&#x27;blog&#x27;, __name__)<br><br>@article.route(&#x27;/&#x27;)<br>def articleIndex():<br>    return &quot;I&#x27;m article index&quot;<br></code></pre></td></tr></table></figure><p>可以看到我们首先需要引用flask的 Blueprint 模块，然后像创建普通flask一样创建一个Blueprint对象，其中第一个参数为该app的名字，会在使用url_for()的时候用到。一个flask项目里蓝图的名字不可以重复。<br>接着就是给该app创建路由，可能有的人会疑惑，为什么article的路由也是’&#x2F;‘,不会和start.py里的路由冲突吗？</p><p>接下来回到start.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python3">from flask import Flask<br>from article import article<br><br>app = Flask(__name__)<br>app.register_blueprint(article, url_prefix=&#x27;/article&#x27;)<br></code></pre></td></tr></table></figure><p>可以看到多了两行代码，第一个是从article文件引用名为article的Blueprint对象。<br>第二就是注册一个蓝图，第一个参数为蓝图对象。重点在第二个参数，我们设置了 url_prefix&#x3D;’&#x2F;article’ 。 这样当用户访问 <a href="http://127.0.0.1/article/">http://127.0.0.1/article/</a> 的时候，就会在article的蓝图里寻找’&#x2F;‘这个路由，而不是在start.py里找’&#x2F;‘路由，因此避免了冲突<br>访问<a href="http://127.0.0.1/article/">http://127.0.0.1/article/</a> 时，就会看到”I’m article index”</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python的装饰器详解</title>
    <link href="/2020/12/20/Python%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/12/20/Python%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Python的装饰器绝对算得上是一个十分有用的功能，可以极大的提高效率并减少代码量.</p><h2 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>要使用装饰器，首先需要了解python的函数。在python里，一切皆为函数。这里我们定义一个函数’start’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs Python3">def start():<br>    print(&#x27;hi&#x27;)<br>    return &quot;I am return&quot;<br></code></pre></td></tr></table></figure><p>此时我们有三种方式调用这个函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python3"># 第一种<br>start()<br># hi<br><br># 第二种<br>func = start()<br>print(func)<br># hi<br># I am return<br><br># 第三种<br>func = start<br>func()<br># hi<br></code></pre></td></tr></table></figure><p>区别在于</p><ol><li>第一种通过直接调用函数，执行函数内的指令，但是没用输出函数的返回值</li><li>第二种执行函数，并把函数的返回值赋值给 func，再输出 func。 此时就得到了两条输出</li><li>直接把函数赋值给func(注意，赋值函数的时候并没用加上(), 加上的话就会直接执行)， 再在func后面加上() 来执行函数，此时相当于直接执行 start()</li></ol><h3 id="装饰器是什么？"><a href="#装饰器是什么？" class="headerlink" title="装饰器是什么？"></a>装饰器是什么？</h3><p>装饰器说白了就是可以在函数执行前，把函数给打包一遍，在函数前后可以加一些代码然后再执行。多用于后端的权限认证等功能</p><p>实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python3"># 首先创建一个装器饰<br>def co(func):<br>    def wrapper():<br>        print(&quot;hi&quot;)<br>        func()<br>        print(&quot;end&quot;)<br>    return wrapper<br><br># 在函数前加上&#x27;@装饰器名&#x27;<br>@co<br>def work():<br>    print(&quot;I&#x27;m work&quot;)<br><br># 执行函数<br>work()<br><br># hi<br># I&#x27;m work<br># end<br></code></pre></td></tr></table></figure><p>在执行 work() 的时候发生了什么？</p><ol><li>首先，由于work的前面有装饰器的原因，在执行work的时候并不会直接先执行work。而是把 work这个对象(注意是’work’不是’work()’)传给 co 这个装饰器</li><li>co 装饰器接收work对象，并且返回了wrapper这个对象。其中，wrapper对象执行了三条命令。 分别为 输出、执行函数、输出</li><li>于是python开始执行返回的这个wrapper,就输出了以上的结果</li></ol><h3 id="遇到有参数的情况怎么处理？"><a href="#遇到有参数的情况怎么处理？" class="headerlink" title="遇到有参数的情况怎么处理？"></a>遇到有参数的情况怎么处理？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python3">def co(func):<br>    def wrapper(*args):<br>        print(&quot;hi&quot;)<br>        print(&quot;接收到了参数:&quot;, *args)<br>        func(*args)<br>        print(&quot;end&quot;)<br>    return wrapper<br><br>@co<br>def work(request):<br>    print(&quot;I&#x27;m work&quot;)<br><br><br>work(&quot;我是参数&quot;)<br><br># hi<br># 接收到了参数: 我是参数<br># I&#x27;m work<br># end<br></code></pre></td></tr></table></figure><p>在遇到有参数的函数时，只需要在装饰器返回的函数(wrapper)里定义和传入函数(work)一样多的参数就可以. 当然，也可以用’*args’代替.<br>需要注意的是，在wrapper里的func()里，同样也需要把参数给传入进去，否则wrapper里的func将无法正常执行.</p><h3 id="多个装饰器的情况下如何处理？"><a href="#多个装饰器的情况下如何处理？" class="headerlink" title="多个装饰器的情况下如何处理？"></a>多个装饰器的情况下如何处理？</h3><p>在多个装饰器的情况下，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python3">@newco<br>@co<br>def work():<br>   print(&quot;I&#x27;m work&quot;)<br></code></pre></td></tr></table></figure><p>work函数首先会传入到co的装饰器里，在co打包好并返回一个函数时(我们将返回的这个函数成为 newFunc), newFunc会作为函数传入到newco这个装饰器内，然后就和普通的装饰器一样的处理</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>单点登录系统(Central Authentication Server)</title>
    <link href="/2020/12/11/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F-Central-Authentication-Server/"/>
    <url>/2020/12/11/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F-Central-Authentication-Server/</url>
    
    <content type="html"><![CDATA[<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>分布式系统的用户授权验证</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>由于HTTP协议的跨域限制，不同域名无法共用同一处的Cookies. CAS可以做到用户一次登录就可以在不同的域名网站下无障碍的通过</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><img src="/2020/12/11/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F-Central-Authentication-Server/img1.png" class=""><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><ul><li>用户端[4]访问装有CAS客户端的网站[1]</li><li>[1]发现[4]并未携带cookies或cookies失效</li><li>[1]返回重定向到CAS服务端[3],并附带上[1]的URL</li></ul><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><ul><li>[4]访问[3]</li></ul><h3 id="用户认证"><a href="#用户认证" class="headerlink" title="用户认证"></a>用户认证</h3><ul><li>[3]返回登录界面到[4]</li><li>[4]输入正确的用户名和密码，并发送给[3]</li><li>[3]验证成功后，生成一个ST(Server Ticket).返回一个重定向到[1]的URL并附带上这个ST.同时在cookies中设置一个名为TGC(Ticket Granted Cookie)的TGT(Ticket Granted Ticket). 如果向[3]发送TGC可以查询到对应的TGT，通过TGT可以生成ST</li></ul><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ul><li>[4]访问[3]发来的重定向URL，访问[1].</li><li>[1]拿到[4]发送来的ST后，访问[3]对该ST进行验证</li><li>[3]验证该ST有效后，返回给[1]</li><li>[1]收到[3]的验证后，生成一个[4]的session，并把该session设置在[4]的cookies里.下次[4]再次访问时就可以根据这个session进行验证，不用再通过[3]</li></ul><h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><p>此时，如果[4]还想继续访问一个不同域名但同CAS服务器的网站[A]</p><ul><li>[A]会返回一个重定向到[3]的URL给[4]</li><li>[4]在访问[3]的时候会携带TGC</li><li>[3]在确认该TGC有效后，会生成一个对应的ST返回给[4]并重定向到[A]</li><li>[4]携带该ST访问[A]</li><li>[A]拿到该ST后向[4]发起验证，验证通过后存在session里并写入[3]的cookies</li><li>当下次[4]再访问[A]时，只需要携带这个cookies，不需要再验证</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>内存页面置换常见的三种算法</title>
    <link href="/2020/10/12/%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AE%97%E6%B3%95/"/>
    <url>/2020/10/12/%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ul><li><h3 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h3><p> 该算法维护一个字典，存留所有已遍历过的页面以及上次遍历到当前的距离。每轮遍历都使字典里的value + 1<br>遇到需要替换时，遍历该字典找到最大value(既最久没有使用的页面)对应的index并进行替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><pre><code class="hljs python3"># LRU algorithm<br>def lru(data):<br>    memory = []<br>    fault = 0<br>    last_reference = &#123;&#125;<br>    for page in data:<br>        for node in last_reference:<br>            last_reference[node] += 1<br>        last_reference[page] = 0<br>        <br>        <br>        <br>        if memory.count(page) == 0:     # This page is not exists in the list<br>            if len(memory) &lt; numOfFrames:<br>                memory.append(page)<br>            else:<br>                fault += 1<br><br>                recently = None<br>                for node in last_reference:<br>                    <br>                    if recently == None:<br>                        recently = node<br>                        continue<br>                    elif last_reference[node] &gt; last_reference[recently]:<br>                        recently = node<br><br>                memory[memory.index(recently)] = page<br>                last_reference.pop(recently)<br>        else:<br>            last_reference[page] = 0<br>        # print(memory, page)<br>        # print(last_reference)<br><br>        print(memory, &quot;numbers of fault:&quot;, fault)<br></code></pre></td></tr></table></figure></li><li><h3 id="FIFO算法"><a href="#FIFO算法" class="headerlink" title="FIFO算法"></a>FIFO算法</h3><p>该算法维护一个变量，指向当前内存中最早插入的页面。<br>遇到需要替换时，pop这个变量指向的内容并且在该位置插入页面。再把该变量+1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python3"># FIFO algorithm<br>def fifo(data):<br>    memory = []<br>    fault = 0<br>    oldestAddr = 0<br>    for page in data:<br>        if oldestAddr &gt;= numOfFrames:<br>            oldestAddr -= numOfFrames<br><br>        if page not in memory:<br>            if len(memory) &lt; numOfFrames:<br>                memory.append(page)<br>            else:<br>                memory.pop(oldestAddr)<br>                memory.insert(oldestAddr, page)<br>                fault += 1<br>                oldestAddr += 1<br>        print(memory, &quot;numbers of fault:&quot;, fault)<br></code></pre></td></tr></table></figure></li><li><h3 id="Optimal算法"><a href="#Optimal算法" class="headerlink" title="Optimal算法"></a>Optimal算法</h3><p>该算法在遇到需要替换时，会搜索当前内存中的页面是否在后续出现。如果后续不再出现，则替换该页面。如果内存中的所有页面都在后续出现，则选取到当前距离最大的页面进行替换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python3"># OPTIMAL algorithm<br>def optimal(data):<br>    memory = []<br>    fault = 0<br>    for index, page in enumerate(data):<br>        if len(memory) &lt; numOfFrames:<br>            if memory.count(page) == 0:     # current page is not existing<br>                memory.append(page)<br><br>        elif memory.count(page) == 0:<br>            fault += 1<br>            # pick one to replace<br>            next_use = &#123;&#125;<br>            pick = None<br>            # check if use furture<br>            for temp in memory:<br>                if temp not in data[index:]:      # doesnt use furture<br>                    pick = temp<br>                    break<br>                else:   # use in furture<br>                    distance = data[index:].index(temp)<br>                    next_use[temp] = distance<br>            else:   # every node is use in furture<br>                # calculate farest node<br>                for node in next_use:<br>                    if pick == None:<br>                        pick = node<br>                    else:<br>                        if next_use[node] &gt; next_use[pick]:<br>                            pick = node<br>            <br>            memory[memory.index(pick)] = page<br>        print(memory, page)<br>    print(memory, &quot;numbers of fault:&quot;, fault)<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何基于FLASK使用HTTPS?</title>
    <link href="/2020/04/22/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8EFLASK%E4%BD%BF%E7%94%A8HTTPS/"/>
    <url>/2020/04/22/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8EFLASK%E4%BD%BF%E7%94%A8HTTPS/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>最近在做微信小程序，用PYTHON的FLASK作为后台。由于微信小程序规定必须使用HTTPS为通信方式，于是便开始尝试基于FLASK的HTTPS.</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ol><li>域名</li><li>服务器</li></ol><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="1-为域名申请一个SSL证书"><a href="#1-为域名申请一个SSL证书" class="headerlink" title="1.为域名申请一个SSL证书"></a>1.为域名申请一个SSL证书</h3><img src="/2020/04/22/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8EFLASK%E4%BD%BF%E7%94%A8HTTPS/img1.png" class=""><h3 id="2-申请成功后，下载证书"><a href="#2-申请成功后，下载证书" class="headerlink" title="2.申请成功后，下载证书"></a>2.申请成功后，下载证书</h3><img src="/2020/04/22/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8EFLASK%E4%BD%BF%E7%94%A8HTTPS/img2.png" class=""><p>打开压缩文件里的NGINX文件夹，上传里面的两个文件到服务器</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs python3">from flask import Flask<br><br>app = Flask(__name__)<br><br><br>@app.route(&quot;/&quot;)<br>def index():<br>    return &quot;&lt;h1&gt;hello world!&lt;/h1&gt;&quot;<br><br><br>if __name__ == &quot;__main__&quot;:<br>    app.run(host=&quot;0.0.0.0&quot;, port=80, debug=True, ssl_context=(&quot;xxx.crt&quot;, &quot;xxx.key&quot;))<br></code></pre></td></tr></table></figure><p>xxx.crt 和 xxx.key  分别对应两个文件的目录<br>接着在服务器启动</p><h3 id="4-演示"><a href="#4-演示" class="headerlink" title="4. 演示"></a>4. 演示</h3><img src="/2020/04/22/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8EFLASK%E4%BD%BF%E7%94%A8HTTPS/img3.png" class="">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>用Python解决RADIX-SORT</title>
    <link href="/2020/04/17/%E7%94%A8Python%E8%A7%A3%E5%86%B3RADIX-SORT/"/>
    <url>/2020/04/17/%E7%94%A8Python%E8%A7%A3%E5%86%B3RADIX-SORT/</url>
    
    <content type="html"><![CDATA[<p>用radix-sort解决一个每个元素含有三个字符的列表排序问题。</p><blockquote><p>“illustrate the operation of RADIX-SORT on the following list of English words: COW, DOG, SEA, RUG, ROW, MOB, BOX, TAB, BAR, EAR, TAR, DIG, BIG, TEA, NOW, FOX.”</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>每个元素由3个字符组成</li><li>每个字符都为大写的A-Z</li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>创建一个列表内含26个空的列表</li><li>利用python的特性，从倒数开始排序(index &#x3D; -1)</li><li>获取每个元素的某个字符，转换成aciss，再放到相应的列表里</li><li>按顺序取出每个list里的字符串，赋值给源列表</li><li>循环3次以上步骤，最后输出即可得到radix-sort后的列表</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs Python3">list = [&quot;COW&quot;, &quot;DOG&quot;, &quot;SEA&quot;, &quot;RUG&quot;, &quot;MOB&quot;,<br>        &quot;BOX&quot;, &quot;TAB&quot;, &quot;BAR&quot;, &quot;EAR&quot;, &quot;TAR&quot;,<br>        &quot;DIG&quot;, &quot;BIG&quot;, &quot;TEA&quot;, &quot;NOW&quot;, &quot;FOX&quot;]<br><br>result = [[] for _ in range(26)]<br>start = -1<br>temp = []<br><br>for x in range(3):<br>    for word in list:<br>        result[ord(word[start]) - 65].append(word)<br><br>    for chars in result:<br>        for x in chars:<br>            if x != []:<br>                temp.append(x)<br><br>    list = temp<br>    temp = []<br>    result = [[] for _ in range(26)]<br><br>    start -= 1<br><br>print(list)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
